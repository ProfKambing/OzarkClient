package me.trambled.ozark.ozarkclient.module.exploit;

import me.trambled.ozark.ozarkclient.event.events.EventDamageBlock;
import me.trambled.ozark.ozarkclient.event.events.EventRender;
import me.trambled.ozark.ozarkclient.module.Category;
import me.trambled.ozark.ozarkclient.module.Module;
import me.trambled.ozark.ozarkclient.module.Setting;
import me.trambled.ozark.ozarkclient.util.render.RenderUtil;
import me.trambled.turok.draw.RenderHelp;
import me.zero.alpine.fork.listener.EventHandler;
import me.zero.alpine.fork.listener.Listener;
import net.minecraft.block.Block;
import net.minecraft.block.state.IBlockState;
import net.minecraft.client.renderer.RenderHelper;
import net.minecraft.client.renderer.entity.Render;
import net.minecraft.init.Blocks;
import net.minecraft.network.play.client.CPacketPlayerDigging;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.BlockPos;

public class PacketMine extends Module {

    public PacketMine() {
        super(Category.EXPLOIT);

        this.name = "PacketMine";
        this.tag = "PacketMine";
        this.description = "using packets to mine";
    }

    Setting render_mode = create("Render", "PacketMineMode", "None", combobox("Pretty", "Solid", "Outline", "BowTie", "None"));
    Setting height = create("Height", "PacketMineHeight", 1.0, 0.0, 1.0);
    Setting r = create("R", "PacketMineR", 255, 0, 255);
    Setting g = create("G", "PacketMineG", 255, 0, 255);
    Setting b = create("B", "PacketMineB", 255, 0, 255);
    Setting a = create("Solid A", "PacketMineA", 100, 0, 255);
    Setting a_out = create("Outline A", "PacketMineOutlineA", 255, 0, 255);
    Setting line_width = create("Outline Width", "HoleESPLineWidth", 1f, 0.1f, 5f);

    BlockPos render_pos;
    private boolean outline;
    private boolean solid;

    @EventHandler
    private Listener<EventDamageBlock> on_damage_block = new Listener<>(event -> {

        if (!can_break(event.getPos())) return;

        render_pos = event.getPos();

        mc.player.swingArm(EnumHand.MAIN_HAND);
        mc.player.connection.sendPacket(new CPacketPlayerDigging(
                CPacketPlayerDigging.Action.START_DESTROY_BLOCK, event.getPos(), event.getDirection()
        ));
        mc.player.connection.sendPacket(new CPacketPlayerDigging(
                CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, event.getPos(), event.getDirection()
        ));

        event.cancel();
    });

    @Override
    public void render(EventRender event) {

        if (render_pos == null) return;

        if (mc.world.getBlockState(render_pos).getBlock().equals(Blocks.AIR)) {
            render_pos = null;
            return;
        }

        if (render_mode.in("None") || render_mode.in("BowTie")){
            outline = false;
            solid = false;
        }

        if (render_mode.in("Pretty")) {
            outline = true;
            solid = true;
        }

        if (render_mode.in("Solid")) {
            outline = false;
            solid = true;
        }

        if (render_mode.in("Outline")) {
            outline = true;
            solid = false;
        }

        float h = (float) height.get_value(1.0);

        if (solid) {
            RenderHelp.prepare("quads");
            RenderHelp.draw_cube(RenderHelp.get_buffer_build(),
                    render_pos.getX(), render_pos.getY(), render_pos.getZ(),
                    1, h, 1,
                    r.get_value(1), g.get_value(1), b.get_value(1), a_out.get_value(1),
                    "all"
            );
            RenderHelp.release();
        }

        if (outline) {
            RenderHelp.prepare("lines");
            RenderHelp.draw_cube_line(RenderHelp.get_buffer_build(),
                    render_pos.getX(), render_pos.getY(), render_pos.getZ(),
                    1, 1, 1,
                    r.get_value(1), g.get_value(1), b.get_value(1), a.get_value(1), (float) line_width.get_value(1d),
                    "all"
            );

            RenderHelp.release();
        }
        if (render_mode.in("BowTie")) {
            RenderHelp.prepare("lines");
            RenderHelp.draw_triangle_line(RenderHelp.get_buffer_build(),
                    render_pos.getX(), render_pos.getY(), render_pos.getZ(),
                    1, 1, 1,
                    r.get_value(1), g.get_value(1), b.get_value(1), a.get_value(1), (float) line_width.get_value(1d),
                    "all"
            );
            RenderHelp.release();
        }
    }

    @Override
    public void update_always() {
        a_out.set_shown(outline);
        line_width.set_shown(outline || render_mode.in("BowTie"));
        a.set_shown(solid);

    }



    private boolean can_break(BlockPos pos)
    {
        final IBlockState blockState = mc.world.getBlockState(pos);
        final Block block = blockState.getBlock();

        return block.getBlockHardness(blockState, mc.world, pos) != -1;
    }

}