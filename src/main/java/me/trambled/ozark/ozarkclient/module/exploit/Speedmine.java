package me.trambled.ozark.ozarkclient.module.exploit;

import me.trambled.ozark.ozarkclient.event.events.EventBlock;
import me.trambled.ozark.ozarkclient.event.events.EventPacket;
import me.trambled.ozark.ozarkclient.module.Category;
import me.trambled.ozark.ozarkclient.module.Module;
import me.trambled.ozark.ozarkclient.module.Setting;
import me.trambled.ozark.ozarkclient.util.world.TimerUtil;
import me.zero.alpine.fork.listener.EventHandler;
import me.zero.alpine.fork.listener.Listener;
import net.minecraft.block.Block;
import net.minecraft.block.state.IBlockState;
import net.minecraft.entity.Entity;
import net.minecraft.entity.item.EntityEnderCrystal;
import net.minecraft.init.Blocks;
import net.minecraft.network.play.client.CPacketAnimation;
import net.minecraft.network.play.client.CPacketPlayerDigging;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.BlockPos;

public class Speedmine extends Module {
    
    public Speedmine() {
        super(Category.EXPLOIT);

        this.name        = "SpeedMine";
        this.tag         = "SpeedMine";
        this.description = "Mine faster.";
    }

    Setting mode = create("Mode", "SpeedmineMode", "Normal", combobox("Normal", "Packet", "Damage", "Instant", "Breaker"));
    Setting damage = create("Damage Ammount", "SpeedmineDamagaeAmmount", 0.7, 0, 1);
    Setting reset = create("Reset", "SpeedmineReset", true);
    Setting no_break_anim = create("No Break Anim", "SpeedMineBreakAnim", false);
    Setting no_delay = create("No Delay", "SpeedmineNoDelay", false);
    Setting no_swing = create("No Swing", "SpeedmineNoSwing", false);
    Setting allow = create("MultiTask", "SpeedmineMultiTask", false);
    Setting double_break = create("Double Break", "SpeedmineDoubleBreak", false);

    private final TimerUtil timer = new TimerUtil();

    private IBlockState current_block_state = null;

    private BlockPos current_pos = null;
    private BlockPos last_pos = null;

    private BlockPos blockAimed;
    private BlockPos lastBlock;
    private EnumFacing direction;


    private EnumFacing last_facing = null;

    private boolean is_mining = false;

    @Override
    public void update() {
        if (current_pos != null &&
                (!mc.world.getBlockState(current_pos).equals(current_block_state) || mc.world.getBlockState(current_pos).getBlock() == Blocks.AIR)) {
                current_pos = null;
                current_block_state = null;
        }

        if (no_delay.get_value(true)) {
            mc.playerController.blockHitDelay = 0;
        }

        if (is_mining && last_pos != null && last_facing != null && no_break_anim.get_value(true)) {
            mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.ABORT_DESTROY_BLOCK, last_pos, last_facing));
        }

        if (reset.get_value(true) && mc.gameSettings.keyBindUseItem.isKeyDown() && !allow.get_value(true)) {
            mc.playerController.isHittingBlock = false;
        }
    }

    @EventHandler
    private final Listener<EventPacket.SendPacket> send_listener = new Listener<>( event -> {
        if (no_swing.get_value(true) && event.get_packet() instanceof CPacketAnimation) {
            event.cancel();
        }

        if (no_break_anim.get_value(true) && event.get_packet() instanceof CPacketPlayerDigging) {
            final CPacketPlayerDigging p = (CPacketPlayerDigging) event.get_packet();
            try {
                for (final Entity entity : mc.world.getEntitiesWithinAABBExcludingEntity(null, new AxisAlignedBB(p.getPosition()))) {
                    if (entity instanceof EntityEnderCrystal) {
                        show_anim();
                        return;
                    }
                }
            } catch (Exception ignored){}

            if (p.getAction().equals(CPacketPlayerDigging.Action.START_DESTROY_BLOCK)) {
                show_anim(true, p.getPosition(), p.getFacing());
            }

            if (p.getAction().equals(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK)) {
                show_anim();
            }
        }
    });

    @EventHandler
    private final Listener<EventBlock> block_event = new Listener<>( event -> {
        if (event.get_stage() == 3 && reset.get_value(true) && mc.playerController.curBlockDamageMP > 0.1f) {
            mc.playerController.isHittingBlock = true;
        }
        if (event.get_stage() == 4 && !mode.in("Normal")) {
            if (canBreak(event.pos)) {
                if (reset.get_value(true)) {
                    mc.playerController.isHittingBlock = false;
                }

                if (mode.in("Packet")) {
                    if (current_pos == null) {
                        current_pos = event.pos;
                        current_block_state = mc.world.getBlockState(current_pos);
                        timer.reset();
                    }
                    mc.player.swingArm(EnumHand.MAIN_HAND);
                    mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, event.pos, event.facing));
                    mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, event.pos, event.facing));
                    event.cancel();
                }

                if (mode.in("Damage")) {
                    if (mc.playerController.curBlockDamageMP >= damage.get_value(1)) {
                        mc.playerController.curBlockDamageMP = 1.0f;
                    }
                }

                if (mode.in("Instant")) {
                    mc.player.swingArm(EnumHand.MAIN_HAND);
                    mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, event.pos, event.facing));
                    mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, event.pos, event.facing));
                    mc.playerController.onPlayerDestroyBlock(event.pos);
                    mc.world.setBlockToAir(event.pos);
                }

                if (mode.in("Breaker")) {
				/*
					This is what i understood about this module:
					First, it has to break the block normally with START_DESTROY_BLOCK and then STOP_DESTROY_BlOCK
					the second block, it just spam STOP_DESTROY_BLOCK, making it insta.
				 */
                    blockAimed = event.pos;
                    if (canBreak(event.pos)) {
                        // If it's not the same block
                        if (lastBlock == null || event.pos.getX() != lastBlock.getX() || event.pos.getY() != lastBlock.getY() || event.pos.getZ() != lastBlock.getZ()) {
                            // Start destroying with START_DESTROY_BLOCK
                            mc.player.swingArm(EnumHand.MAIN_HAND);
                            mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK,
                                    event.pos, event.facing));
                            // Save for preventing it doing again packet mine
                            lastBlock = event.pos;
                            direction = event.facing;
                        }

                        // Send STOP_DESTROY_BLOCK
                        mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK,
                                lastBlock, direction));
                        // Cancel the normal mine
                        event.cancel();

                    }
                }

            }

            if (double_break.get_value(true)) {
                final BlockPos above = event.pos.up();
                if (canBreak(above) && mc.player.getDistance(above.getX(), above.getY(), above.getZ()) <= 5.0) {
                    mc.player.swingArm(EnumHand.MAIN_HAND);
                    mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, above, event.facing));
                    mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, above, event.facing));
                    mc.playerController.onPlayerDestroyBlock(above);
                    mc.world.setBlockToAir(above);
                }
            }

        }
    });

    public void show_anim(final boolean is_mining, final BlockPos last_pos, final EnumFacing last_facing) {
        this.is_mining = is_mining;
        this.last_pos = last_pos;
        this.last_facing = last_facing;
    }

    public void show_anim() {
        this.show_anim(false, null, null);
    }

    @Override
    public String array_detail() {
        return mode.get_current_value();
    }

    public static boolean canBreak(final BlockPos pos) {
        final IBlockState blockState = mc.world.getBlockState(pos);
        final Block block = blockState.getBlock();
        return block.getBlockHardness(blockState, mc.world, pos) != -1.0f;
    }

}